"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = main;
exports.generateXML = generateXML;
exports.getPermaLink = getPermaLink;

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _path = _interopRequireDefault(require("path"));

var _reactStatic = require("react-static");

var _chalk = _interopRequireDefault(require("chalk"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var REGEX_TO_GET_LAST_SLASH = /\/{1,}$/gm;

var defaultGetUrlAttributes = function defaultGetUrlAttributes(route, _ref) {
  var prefixPath = _ref.prefixPath;
  var _route$sitemap = route.sitemap;
  _route$sitemap = _route$sitemap === void 0 ? {} : _route$sitemap;

  var loc = _route$sitemap.loc,
      hreflang = _route$sitemap.hreflang,
      rest = _objectWithoutProperties(_route$sitemap, ["loc", "hreflang"]);

  return _objectSpread({
    loc: getPermaLink(loc || route.path, prefixPath)
  }, rest);
};

function main(_x, _x2) {
  return _main.apply(this, arguments);
}

function _main() {
  _main = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(state, options) {
    var _state$config, DIST, disableRoutePrefixing, siteRoot, publicPath, staging, prefixPath, filename, xml;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _state$config = state.config, DIST = _state$config.paths.DIST, disableRoutePrefixing = _state$config.disableRoutePrefixing, siteRoot = _state$config.siteRoot, publicPath = _state$config.publicPath, staging = state.staging;
            prefixPath = disableRoutePrefixing ? siteRoot : publicPath;
            filename = staging ? 'sitemap.staging.xml' : 'sitemap.xml';
            console.log("Generating ".concat(filename, "..."));
            xml = generateXML(state, options, prefixPath);
            _context.next = 7;
            return _fsExtra["default"].writeFile(_path["default"].join(DIST, filename), xml);

          case 7:
            console.log(_chalk["default"].green("[\u2713] ".concat(filename, " generated")));

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _main.apply(this, arguments);
}

function generateXML(state) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$getAttributes = _ref2.getAttributes,
      getAttributes = _ref2$getAttributes === void 0 ? function () {
    return {};
  } : _ref2$getAttributes;

  var prefixPath = arguments.length > 2 ? arguments[2] : undefined;
  var config = state.config,
      routes = state.routes,
      staging = state.staging;

  if (!prefixPath) {
    throw new Error('The sitemap url prefix cannot be empty or undefined!');
  }

  var xmlRoutes = routes.filter(function (r) {
    // Don't include the 404 page
    if (r.path === '404') {
      return false;
    } // Don't include routes with noindex: true


    if (r.noindex) {
      return false;
    }

    return true;
  }) // Leave out noindex routes
  .map(function (route) {
    var attributes = _objectSpread(_objectSpread(_objectSpread({}, defaultGetUrlAttributes(route, {
      config: config,
      prefixPath: prefixPath
    })), getAttributes(route, {
      config: config,
      prefixPath: prefixPath
    })), {}, {
      noindex: undefined
    });

    var attributesArr = [];
    Object.keys(attributes).forEach(function (key) {
      if (typeof attributes[key] !== 'undefined') {
        attributesArr.push({
          key: key,
          value: attributes[key]
        });
      }
    });
    var hrefLangLinks = (route.sitemap && route.sitemap.hreflang ? buildHrefLangLinks(route.sitemap.hreflang, prefixPath) : []).join(staging ? '\n' : '');
    return ['<url>', xmlArrayOutput(attributesArr, staging), hrefLangLinks, '</url>'].join(staging ? '\n' : '');
  }).join(staging ? '\n' : '');
  return ["<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\">", xmlRoutes, "</urlset>"].join(staging ? '\n' : '');
}

function getPermaLink(path, prefixPath) {
  var permalink = "".concat(prefixPath).concat((0, _reactStatic.pathJoin)(path));
  return "".concat(permalink, "/").replace(REGEX_TO_GET_LAST_SLASH, '/');
}

function checkNestedValue(value) {
  if (!value) return false;

  if (_typeof(value) === 'object' && value !== null) {
    return true;
  } else {
    return false;
  }
}

function convertNestedValue(values, staging) {
  var _values = [];
  Object.keys(values).forEach(function (key) {
    if (typeof values[key] !== 'undefined') {
      _values.push({
        key: key,
        value: values[key]
      });
    }
  });
  return xmlArrayOutput(_values, staging);
}

function encode(val) {
  return String(val).replace(/[<>&'"]/g, function (c) {
    switch (c) {
      case '<':
        return '&lt;';

      case '>':
        return '&gt;';

      case '&':
        return '&amp;';

      case "'":
        return '&apos;';

      case '"':
        return '&quot;';

      default:
        throw new Error('XML encoding failed');
    }
  });
}

function buildHrefLangLinks(hrefLangConfig, prefixPath) {
  return hrefLangConfig.map(function (_ref3) {
    var language = _ref3.language,
        url = _ref3.url;
    return "<xhtml:link rel=\"alternate\" hreflang=\"".concat(language, "\" href=\"").concat(getPermaLink(url, prefixPath), "\" />");
  });
}

function xmlArrayOutput(values, staging) {
  return _toConsumableArray(values.map(function (_ref4) {
    var key = _ref4.key,
        value = _ref4.value;
    return "<".concat(key, ">").concat(checkNestedValue(value) ? convertNestedValue(value, staging) : encode(value), "</").concat(key, ">");
  }).join(staging ? '\n' : '')).join(staging ? '\n' : '');
}
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _chalk = _interopRequireDefault(require("chalk"));

var _slash = _interopRequireDefault(require("slash"));

var _path = _interopRequireDefault(require("path"));

var _utils = require("../utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var _default = /*#__PURE__*/function () {
  var _extractTemplates = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(state) {
    var config, routes, incremental, templates, notFoundPending;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            config = state.config, routes = state.routes, incremental = state.incremental;
            console.log('Building Templates...');
            (0, _utils.time)(_chalk["default"].green("[\u2713] Templates Built")); // Dedupe all templates into an array

            templates = [];
            notFoundPending = true;
            routes.forEach(function (route) {
              if (!route.template) {
                return;
              }

              route.template = (0, _slash["default"])("__react_static_root__/".concat(_path["default"].relative(config.paths.ROOT, route.template))); // Check if the template has already been added

              var index = templates.indexOf(route.template);

              if (index === -1) {
                // If it's new, add it
                if ((0, _utils.is404Path)(route.path)) {
                  // Make sure 404 template is the first one
                  templates.unshift(route.template);
                  notFoundPending = false;
                } else {
                  templates.push(route.template);
                }
              }
            });
            (0, _utils.timeEnd)(_chalk["default"].green("[\u2713] Templates Built"));

            if (!(!incremental && notFoundPending)) {
              _context.next = 9;
              break;
            }

            throw new Error('A 404 template was not found at template extraction time. It should have been at least defaulted to one by now, so this is very bad. File an issue if you see this.');

          case 9:
            return _context.abrupt("return", _objectSpread(_objectSpread({}, state), {}, {
              templates: templates
            }));

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  function extractTemplates(_x) {
    return _extractTemplates.apply(this, arguments);
  }

  return extractTemplates;
}();

exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdGF0aWMvZXh0cmFjdFRlbXBsYXRlcy5qcyJdLCJuYW1lcyI6WyJzdGF0ZSIsImNvbmZpZyIsInJvdXRlcyIsImluY3JlbWVudGFsIiwiY29uc29sZSIsImxvZyIsImNoYWxrIiwiZ3JlZW4iLCJ0ZW1wbGF0ZXMiLCJub3RGb3VuZFBlbmRpbmciLCJmb3JFYWNoIiwicm91dGUiLCJ0ZW1wbGF0ZSIsInBhdGgiLCJyZWxhdGl2ZSIsInBhdGhzIiwiUk9PVCIsImluZGV4IiwiaW5kZXhPZiIsInVuc2hpZnQiLCJwdXNoIiwiRXJyb3IiLCJleHRyYWN0VGVtcGxhdGVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozt3R0FFZ0IsaUJBQWdDQSxLQUFoQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDTkMsWUFBQUEsTUFETSxHQUMwQkQsS0FEMUIsQ0FDTkMsTUFETSxFQUNFQyxNQURGLEdBQzBCRixLQUQxQixDQUNFRSxNQURGLEVBQ1VDLFdBRFYsR0FDMEJILEtBRDFCLENBQ1VHLFdBRFY7QUFFZEMsWUFBQUEsT0FBTyxDQUFDQyxHQUFSLENBQVksdUJBQVo7QUFDQSw2QkFBS0Msa0JBQU1DLEtBQU4sQ0FBWSwwQkFBWixDQUFMLEVBSGMsQ0FLZDs7QUFDTUMsWUFBQUEsU0FOUSxHQU1JLEVBTko7QUFPVkMsWUFBQUEsZUFQVSxHQU9RLElBUFI7QUFTZFAsWUFBQUEsTUFBTSxDQUFDUSxPQUFQLENBQWUsVUFBQUMsS0FBSyxFQUFJO0FBQ3RCLGtCQUFJLENBQUNBLEtBQUssQ0FBQ0MsUUFBWCxFQUFxQjtBQUNuQjtBQUNEOztBQUVERCxjQUFBQSxLQUFLLENBQUNDLFFBQU4sR0FBaUIsdURBQ1VDLGlCQUFLQyxRQUFMLENBQ3ZCYixNQUFNLENBQUNjLEtBQVAsQ0FBYUMsSUFEVSxFQUV2QkwsS0FBSyxDQUFDQyxRQUZpQixDQURWLEVBQWpCLENBTHNCLENBWXRCOztBQUNBLGtCQUFNSyxLQUFLLEdBQUdULFNBQVMsQ0FBQ1UsT0FBVixDQUFrQlAsS0FBSyxDQUFDQyxRQUF4QixDQUFkOztBQUNBLGtCQUFJSyxLQUFLLEtBQUssQ0FBQyxDQUFmLEVBQWtCO0FBQ2hCO0FBQ0Esb0JBQUksc0JBQVVOLEtBQUssQ0FBQ0UsSUFBaEIsQ0FBSixFQUEyQjtBQUN6QjtBQUNBTCxrQkFBQUEsU0FBUyxDQUFDVyxPQUFWLENBQWtCUixLQUFLLENBQUNDLFFBQXhCO0FBQ0FILGtCQUFBQSxlQUFlLEdBQUcsS0FBbEI7QUFDRCxpQkFKRCxNQUlPO0FBQ0xELGtCQUFBQSxTQUFTLENBQUNZLElBQVYsQ0FBZVQsS0FBSyxDQUFDQyxRQUFyQjtBQUNEO0FBQ0Y7QUFDRixhQXhCRDtBQXlCQSxnQ0FBUU4sa0JBQU1DLEtBQU4sQ0FBWSwwQkFBWixDQUFSOztBQWxDYyxrQkFvQ1YsQ0FBQ0osV0FBRCxJQUFnQk0sZUFwQ047QUFBQTtBQUFBO0FBQUE7O0FBQUEsa0JBcUNOLElBQUlZLEtBQUosQ0FDSixxS0FESSxDQXJDTTs7QUFBQTtBQUFBLDZFQTJDVHJCLEtBM0NTO0FBNENaUSxjQUFBQSxTQUFTLEVBQVRBO0FBNUNZOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEc7O1dBQWVjLGdCOzs7O1NBQUFBLGdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNoYWxrIGZyb20gJ2NoYWxrJ1xuaW1wb3J0IHNsYXNoIGZyb20gJ3NsYXNoJ1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCdcbmltcG9ydCB7IHRpbWUsIHRpbWVFbmQsIGlzNDA0UGF0aCB9IGZyb20gJy4uL3V0aWxzJ1xuXG5leHBvcnQgZGVmYXVsdCAoYXN5bmMgZnVuY3Rpb24gZXh0cmFjdFRlbXBsYXRlcyhzdGF0ZSkge1xuICBjb25zdCB7IGNvbmZpZywgcm91dGVzLCBpbmNyZW1lbnRhbCB9ID0gc3RhdGVcbiAgY29uc29sZS5sb2coJ0J1aWxkaW5nIFRlbXBsYXRlcy4uLicpXG4gIHRpbWUoY2hhbGsuZ3JlZW4oJ1tcXHUyNzEzXSBUZW1wbGF0ZXMgQnVpbHQnKSlcblxuICAvLyBEZWR1cGUgYWxsIHRlbXBsYXRlcyBpbnRvIGFuIGFycmF5XG4gIGNvbnN0IHRlbXBsYXRlcyA9IFtdXG4gIGxldCBub3RGb3VuZFBlbmRpbmcgPSB0cnVlXG5cbiAgcm91dGVzLmZvckVhY2gocm91dGUgPT4ge1xuICAgIGlmICghcm91dGUudGVtcGxhdGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHJvdXRlLnRlbXBsYXRlID0gc2xhc2goXG4gICAgICBgX19yZWFjdF9zdGF0aWNfcm9vdF9fLyR7cGF0aC5yZWxhdGl2ZShcbiAgICAgICAgY29uZmlnLnBhdGhzLlJPT1QsXG4gICAgICAgIHJvdXRlLnRlbXBsYXRlXG4gICAgICApfWBcbiAgICApXG5cbiAgICAvLyBDaGVjayBpZiB0aGUgdGVtcGxhdGUgaGFzIGFscmVhZHkgYmVlbiBhZGRlZFxuICAgIGNvbnN0IGluZGV4ID0gdGVtcGxhdGVzLmluZGV4T2Yocm91dGUudGVtcGxhdGUpXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgLy8gSWYgaXQncyBuZXcsIGFkZCBpdFxuICAgICAgaWYgKGlzNDA0UGF0aChyb3V0ZS5wYXRoKSkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgNDA0IHRlbXBsYXRlIGlzIHRoZSBmaXJzdCBvbmVcbiAgICAgICAgdGVtcGxhdGVzLnVuc2hpZnQocm91dGUudGVtcGxhdGUpXG4gICAgICAgIG5vdEZvdW5kUGVuZGluZyA9IGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wbGF0ZXMucHVzaChyb3V0ZS50ZW1wbGF0ZSlcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHRpbWVFbmQoY2hhbGsuZ3JlZW4oJ1tcXHUyNzEzXSBUZW1wbGF0ZXMgQnVpbHQnKSlcblxuICBpZiAoIWluY3JlbWVudGFsICYmIG5vdEZvdW5kUGVuZGluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdBIDQwNCB0ZW1wbGF0ZSB3YXMgbm90IGZvdW5kIGF0IHRlbXBsYXRlIGV4dHJhY3Rpb24gdGltZS4gSXQgc2hvdWxkIGhhdmUgYmVlbiBhdCBsZWFzdCBkZWZhdWx0ZWQgdG8gb25lIGJ5IG5vdywgc28gdGhpcyBpcyB2ZXJ5IGJhZC4gRmlsZSBhbiBpc3N1ZSBpZiB5b3Ugc2VlIHRoaXMuJ1xuICAgIClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgdGVtcGxhdGVzLFxuICB9XG59KVxuIl19
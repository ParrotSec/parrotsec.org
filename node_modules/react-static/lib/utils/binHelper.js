"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var path = require('path');

var PrettyError = require('pretty-error');

var resolveFrom = require('resolve-from');

var Module = require('module'); //


var _require = require('./'),
    escapeRegExp = _require.escapeRegExp; // Allow as much stack tracing as possible


Error.stackTraceLimit = 10000;
var ignorePath;
var originalRequire = Module.prototype.require; // Check and see if we are running react-static from the repo

var needsWorkspaceCheck = __dirname.includes('/react-static/packages/react-static/'); // Recursively checks a module to see if it originated from a
// react-static package in the repo


var inRepo = function inRepo(mod) {
  if (!mod.filename.includes('react-static/packages/react-static/') && mod.filename.includes('react-static/packages/')) {
    return true;
  }

  if (mod.parent) {
    return inRepo(mod.parent);
  }

  return false;
}; // The following ensures that there is always only a single (and same)
// copy of React in an app at any given moment.
// eslint-disable-next-line


Module.prototype.require = function (modulePath) {
  // If we are running in the repo, we need to make sure
  // module resolutions coming from other react-static packages
  // are first attempted from the
  var isInWorkspace = needsWorkspaceCheck && inRepo(this); // Only redirect resolutions to non-relative and non-absolute modules

  if (!modulePath.startsWith('.') && !modulePath.startsWith('/')) {
    if ( // If module is in the repo try and redirect
    isInWorkspace || // Always try and redirect react and react-dom resolutions
    ['react', 'react-dom'].some(function (d) {
      return modulePath.includes(d);
    })) {
      try {
        modulePath = resolveFrom(path.resolve(process.cwd(), 'node_modules'), modulePath);
      } catch (err) {//
      }
    }
  }

  return originalRequire.call(this, modulePath);
};

require('@babel/register')({
  babelrc: false,
  presets: [[path.resolve(__dirname, '../../babel-preset.js'), {
    node: true
  }]],
  ignore: [function babelIgnore(filename) {
    // true if should ignore
    return new RegExp(escapeRegExp("".concat(path.sep, "node_modules").concat(path.sep))).test(filename) || ignorePath && ignorePath.test(filename);
  }]
}); // necessary at any entry point of the cli to ensure that Babel-register
// does not attempt to transform non JavaScript files.


var ignoredExtensions = ['css', 'scss', 'styl', 'less', 'png', 'gif', 'jpg', 'jpeg', 'svg', 'woff', 'woff2', 'ttf', 'eot', 'otf', 'mp4', 'webm', 'ogg', 'mp3', 'wav', 'md', 'yaml'];
ignoredExtensions.forEach(function (ext) {
  require.extensions[".".concat(ext)] = function () {};
});
var originalConsoleError = console.error;

console.error = function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (args.length === 0) {
    return undefined;
  }

  var err = args[0],
      rest = args.slice(1);

  if (err instanceof Error) {
    var _console;

    (_console = console).log.apply(_console, [new PrettyError().render(err)].concat((0, _toConsumableArray2["default"])(rest)));

    return;
  }

  return originalConsoleError.apply(void 0, [err].concat((0, _toConsumableArray2["default"])(rest)));
}; // Be sure to log useful information about unhandled exceptions. This should seriously
// be a default: https://github.com/nodejs/node/issues/9523#issuecomment-259303079


process.on('unhandledRejection', function (r) {
  console.error(r);
});
module.exports = {
  setIgnorePath: function setIgnorePath(path) {
    ignorePath = path ? new RegExp(escapeRegExp(path)) : undefined;
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9iaW5IZWxwZXIuanMiXSwibmFtZXMiOlsicGF0aCIsInJlcXVpcmUiLCJQcmV0dHlFcnJvciIsInJlc29sdmVGcm9tIiwiTW9kdWxlIiwiZXNjYXBlUmVnRXhwIiwiRXJyb3IiLCJzdGFja1RyYWNlTGltaXQiLCJpZ25vcmVQYXRoIiwib3JpZ2luYWxSZXF1aXJlIiwicHJvdG90eXBlIiwibmVlZHNXb3Jrc3BhY2VDaGVjayIsIl9fZGlybmFtZSIsImluY2x1ZGVzIiwiaW5SZXBvIiwibW9kIiwiZmlsZW5hbWUiLCJwYXJlbnQiLCJtb2R1bGVQYXRoIiwiaXNJbldvcmtzcGFjZSIsInN0YXJ0c1dpdGgiLCJzb21lIiwiZCIsInJlc29sdmUiLCJwcm9jZXNzIiwiY3dkIiwiZXJyIiwiY2FsbCIsImJhYmVscmMiLCJwcmVzZXRzIiwibm9kZSIsImlnbm9yZSIsImJhYmVsSWdub3JlIiwiUmVnRXhwIiwic2VwIiwidGVzdCIsImlnbm9yZWRFeHRlbnNpb25zIiwiZm9yRWFjaCIsImV4dCIsImV4dGVuc2lvbnMiLCJvcmlnaW5hbENvbnNvbGVFcnJvciIsImNvbnNvbGUiLCJlcnJvciIsImFyZ3MiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJyZXN0IiwibG9nIiwicmVuZGVyIiwib24iLCJyIiwibW9kdWxlIiwiZXhwb3J0cyIsInNldElnbm9yZVBhdGgiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLElBQU1BLElBQUksR0FBR0MsT0FBTyxDQUFDLE1BQUQsQ0FBcEI7O0FBQ0EsSUFBTUMsV0FBVyxHQUFHRCxPQUFPLENBQUMsY0FBRCxDQUEzQjs7QUFDQSxJQUFNRSxXQUFXLEdBQUdGLE9BQU8sQ0FBQyxjQUFELENBQTNCOztBQUNBLElBQU1HLE1BQU0sR0FBR0gsT0FBTyxDQUFDLFFBQUQsQ0FBdEIsQyxDQUNBOzs7ZUFDeUJBLE9BQU8sQ0FBQyxJQUFELEM7SUFBeEJJLFksWUFBQUEsWSxFQUVSOzs7QUFDQUMsS0FBSyxDQUFDQyxlQUFOLEdBQXdCLEtBQXhCO0FBRUEsSUFBSUMsVUFBSjtBQUVBLElBQU1DLGVBQWUsR0FBR0wsTUFBTSxDQUFDTSxTQUFQLENBQWlCVCxPQUF6QyxDLENBRUE7O0FBQ0EsSUFBTVUsbUJBQW1CLEdBQUdDLFNBQVMsQ0FBQ0MsUUFBVixDQUMxQixzQ0FEMEIsQ0FBNUIsQyxDQUlBO0FBQ0E7OztBQUNBLElBQU1DLE1BQU0sR0FBRyxTQUFUQSxNQUFTLENBQUFDLEdBQUcsRUFBSTtBQUNwQixNQUNFLENBQUNBLEdBQUcsQ0FBQ0MsUUFBSixDQUFhSCxRQUFiLENBQXNCLHFDQUF0QixDQUFELElBQ0FFLEdBQUcsQ0FBQ0MsUUFBSixDQUFhSCxRQUFiLENBQXNCLHdCQUF0QixDQUZGLEVBR0U7QUFDQSxXQUFPLElBQVA7QUFDRDs7QUFDRCxNQUFJRSxHQUFHLENBQUNFLE1BQVIsRUFBZ0I7QUFDZCxXQUFPSCxNQUFNLENBQUNDLEdBQUcsQ0FBQ0UsTUFBTCxDQUFiO0FBQ0Q7O0FBQ0QsU0FBTyxLQUFQO0FBQ0QsQ0FYRCxDLENBYUE7QUFDQTtBQUNBOzs7QUFDQWIsTUFBTSxDQUFDTSxTQUFQLENBQWlCVCxPQUFqQixHQUEyQixVQUFTaUIsVUFBVCxFQUFxQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxNQUFNQyxhQUFhLEdBQUdSLG1CQUFtQixJQUFJRyxNQUFNLENBQUMsSUFBRCxDQUFuRCxDQUo4QyxDQU05Qzs7QUFDQSxNQUFJLENBQUNJLFVBQVUsQ0FBQ0UsVUFBWCxDQUFzQixHQUF0QixDQUFELElBQStCLENBQUNGLFVBQVUsQ0FBQ0UsVUFBWCxDQUFzQixHQUF0QixDQUFwQyxFQUFnRTtBQUM5RCxTQUNFO0FBQ0FELElBQUFBLGFBQWEsSUFDYjtBQUNBLEtBQUMsT0FBRCxFQUFVLFdBQVYsRUFBdUJFLElBQXZCLENBQTRCLFVBQUFDLENBQUM7QUFBQSxhQUFJSixVQUFVLENBQUNMLFFBQVgsQ0FBb0JTLENBQXBCLENBQUo7QUFBQSxLQUE3QixDQUpGLEVBS0U7QUFDQSxVQUFJO0FBQ0ZKLFFBQUFBLFVBQVUsR0FBR2YsV0FBVyxDQUN0QkgsSUFBSSxDQUFDdUIsT0FBTCxDQUFhQyxPQUFPLENBQUNDLEdBQVIsRUFBYixFQUE0QixjQUE1QixDQURzQixFQUV0QlAsVUFGc0IsQ0FBeEI7QUFJRCxPQUxELENBS0UsT0FBT1EsR0FBUCxFQUFZLENBQ1o7QUFDRDtBQUNGO0FBQ0Y7O0FBQ0QsU0FBT2pCLGVBQWUsQ0FBQ2tCLElBQWhCLENBQXFCLElBQXJCLEVBQTJCVCxVQUEzQixDQUFQO0FBQ0QsQ0F6QkQ7O0FBMkJBakIsT0FBTyxDQUFDLGlCQUFELENBQVAsQ0FBMkI7QUFDekIyQixFQUFBQSxPQUFPLEVBQUUsS0FEZ0I7QUFFekJDLEVBQUFBLE9BQU8sRUFBRSxDQUNQLENBQ0U3QixJQUFJLENBQUN1QixPQUFMLENBQWFYLFNBQWIsRUFBd0IsdUJBQXhCLENBREYsRUFFRTtBQUNFa0IsSUFBQUEsSUFBSSxFQUFFO0FBRFIsR0FGRixDQURPLENBRmdCO0FBVXpCQyxFQUFBQSxNQUFNLEVBQUUsQ0FDTixTQUFTQyxXQUFULENBQXFCaEIsUUFBckIsRUFBK0I7QUFDN0I7QUFDQSxXQUNFLElBQUlpQixNQUFKLENBQVc1QixZQUFZLFdBQUlMLElBQUksQ0FBQ2tDLEdBQVQseUJBQTJCbEMsSUFBSSxDQUFDa0MsR0FBaEMsRUFBdkIsRUFBK0RDLElBQS9ELENBQ0VuQixRQURGLEtBR0NSLFVBQVUsSUFBSUEsVUFBVSxDQUFDMkIsSUFBWCxDQUFnQm5CLFFBQWhCLENBSmpCO0FBTUQsR0FUSztBQVZpQixDQUEzQixFLENBdUJBO0FBQ0E7OztBQUNBLElBQU1vQixpQkFBaUIsR0FBRyxDQUN4QixLQUR3QixFQUV4QixNQUZ3QixFQUd4QixNQUh3QixFQUl4QixNQUp3QixFQUt4QixLQUx3QixFQU14QixLQU53QixFQU94QixLQVB3QixFQVF4QixNQVJ3QixFQVN4QixLQVR3QixFQVV4QixNQVZ3QixFQVd4QixPQVh3QixFQVl4QixLQVp3QixFQWF4QixLQWJ3QixFQWN4QixLQWR3QixFQWV4QixLQWZ3QixFQWdCeEIsTUFoQndCLEVBaUJ4QixLQWpCd0IsRUFrQnhCLEtBbEJ3QixFQW1CeEIsS0FuQndCLEVBb0J4QixJQXBCd0IsRUFxQnhCLE1BckJ3QixDQUExQjtBQXVCQUEsaUJBQWlCLENBQUNDLE9BQWxCLENBQTBCLFVBQUFDLEdBQUcsRUFBSTtBQUMvQnJDLEVBQUFBLE9BQU8sQ0FBQ3NDLFVBQVIsWUFBdUJELEdBQXZCLEtBQWdDLFlBQU0sQ0FBRSxDQUF4QztBQUNELENBRkQ7QUFJQSxJQUFNRSxvQkFBb0IsR0FBR0MsT0FBTyxDQUFDQyxLQUFyQzs7QUFDQUQsT0FBTyxDQUFDQyxLQUFSLEdBQWdCLFlBQWE7QUFBQSxvQ0FBVEMsSUFBUztBQUFUQSxJQUFBQSxJQUFTO0FBQUE7O0FBQzNCLE1BQUlBLElBQUksQ0FBQ0MsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNyQixXQUFPQyxTQUFQO0FBQ0Q7O0FBSDBCLE1BSXBCbkIsR0FKb0IsR0FJSmlCLElBSkk7QUFBQSxNQUlaRyxJQUpZLEdBSUpILElBSkk7O0FBSzNCLE1BQUlqQixHQUFHLFlBQVlwQixLQUFuQixFQUEwQjtBQUFBOztBQUN4QixnQkFBQW1DLE9BQU8sRUFBQ00sR0FBUixrQkFBWSxJQUFJN0MsV0FBSixHQUFrQjhDLE1BQWxCLENBQXlCdEIsR0FBekIsQ0FBWiw2Q0FBOENvQixJQUE5Qzs7QUFDQTtBQUNEOztBQUVELFNBQU9OLG9CQUFvQixNQUFwQixVQUFxQmQsR0FBckIsNkNBQTZCb0IsSUFBN0IsR0FBUDtBQUNELENBWEQsQyxDQWFBO0FBQ0E7OztBQUNBdEIsT0FBTyxDQUFDeUIsRUFBUixDQUFXLG9CQUFYLEVBQWlDLFVBQUFDLENBQUMsRUFBSTtBQUNwQ1QsRUFBQUEsT0FBTyxDQUFDQyxLQUFSLENBQWNRLENBQWQ7QUFDRCxDQUZEO0FBSUFDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQjtBQUNmQyxFQUFBQSxhQURlLHlCQUNEckQsSUFEQyxFQUNLO0FBQ2xCUSxJQUFBQSxVQUFVLEdBQUdSLElBQUksR0FBRyxJQUFJaUMsTUFBSixDQUFXNUIsWUFBWSxDQUFDTCxJQUFELENBQXZCLENBQUgsR0FBb0M2QyxTQUFyRDtBQUNEO0FBSGMsQ0FBakIiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBQcmV0dHlFcnJvciA9IHJlcXVpcmUoJ3ByZXR0eS1lcnJvcicpXG5jb25zdCByZXNvbHZlRnJvbSA9IHJlcXVpcmUoJ3Jlc29sdmUtZnJvbScpXG5jb25zdCBNb2R1bGUgPSByZXF1aXJlKCdtb2R1bGUnKVxuLy9cbmNvbnN0IHsgZXNjYXBlUmVnRXhwIH0gPSByZXF1aXJlKCcuLycpXG5cbi8vIEFsbG93IGFzIG11Y2ggc3RhY2sgdHJhY2luZyBhcyBwb3NzaWJsZVxuRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMTAwMDBcblxubGV0IGlnbm9yZVBhdGhcblxuY29uc3Qgb3JpZ2luYWxSZXF1aXJlID0gTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlXG5cbi8vIENoZWNrIGFuZCBzZWUgaWYgd2UgYXJlIHJ1bm5pbmcgcmVhY3Qtc3RhdGljIGZyb20gdGhlIHJlcG9cbmNvbnN0IG5lZWRzV29ya3NwYWNlQ2hlY2sgPSBfX2Rpcm5hbWUuaW5jbHVkZXMoXG4gICcvcmVhY3Qtc3RhdGljL3BhY2thZ2VzL3JlYWN0LXN0YXRpYy8nXG4pXG5cbi8vIFJlY3Vyc2l2ZWx5IGNoZWNrcyBhIG1vZHVsZSB0byBzZWUgaWYgaXQgb3JpZ2luYXRlZCBmcm9tIGFcbi8vIHJlYWN0LXN0YXRpYyBwYWNrYWdlIGluIHRoZSByZXBvXG5jb25zdCBpblJlcG8gPSBtb2QgPT4ge1xuICBpZiAoXG4gICAgIW1vZC5maWxlbmFtZS5pbmNsdWRlcygncmVhY3Qtc3RhdGljL3BhY2thZ2VzL3JlYWN0LXN0YXRpYy8nKSAmJlxuICAgIG1vZC5maWxlbmFtZS5pbmNsdWRlcygncmVhY3Qtc3RhdGljL3BhY2thZ2VzLycpXG4gICkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKG1vZC5wYXJlbnQpIHtcbiAgICByZXR1cm4gaW5SZXBvKG1vZC5wYXJlbnQpXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8vIFRoZSBmb2xsb3dpbmcgZW5zdXJlcyB0aGF0IHRoZXJlIGlzIGFsd2F5cyBvbmx5IGEgc2luZ2xlIChhbmQgc2FtZSlcbi8vIGNvcHkgb2YgUmVhY3QgaW4gYW4gYXBwIGF0IGFueSBnaXZlbiBtb21lbnQuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbk1vZHVsZS5wcm90b3R5cGUucmVxdWlyZSA9IGZ1bmN0aW9uKG1vZHVsZVBhdGgpIHtcbiAgLy8gSWYgd2UgYXJlIHJ1bm5pbmcgaW4gdGhlIHJlcG8sIHdlIG5lZWQgdG8gbWFrZSBzdXJlXG4gIC8vIG1vZHVsZSByZXNvbHV0aW9ucyBjb21pbmcgZnJvbSBvdGhlciByZWFjdC1zdGF0aWMgcGFja2FnZXNcbiAgLy8gYXJlIGZpcnN0IGF0dGVtcHRlZCBmcm9tIHRoZVxuICBjb25zdCBpc0luV29ya3NwYWNlID0gbmVlZHNXb3Jrc3BhY2VDaGVjayAmJiBpblJlcG8odGhpcylcblxuICAvLyBPbmx5IHJlZGlyZWN0IHJlc29sdXRpb25zIHRvIG5vbi1yZWxhdGl2ZSBhbmQgbm9uLWFic29sdXRlIG1vZHVsZXNcbiAgaWYgKCFtb2R1bGVQYXRoLnN0YXJ0c1dpdGgoJy4nKSAmJiAhbW9kdWxlUGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICBpZiAoXG4gICAgICAvLyBJZiBtb2R1bGUgaXMgaW4gdGhlIHJlcG8gdHJ5IGFuZCByZWRpcmVjdFxuICAgICAgaXNJbldvcmtzcGFjZSB8fFxuICAgICAgLy8gQWx3YXlzIHRyeSBhbmQgcmVkaXJlY3QgcmVhY3QgYW5kIHJlYWN0LWRvbSByZXNvbHV0aW9uc1xuICAgICAgWydyZWFjdCcsICdyZWFjdC1kb20nXS5zb21lKGQgPT4gbW9kdWxlUGF0aC5pbmNsdWRlcyhkKSlcbiAgICApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1vZHVsZVBhdGggPSByZXNvbHZlRnJvbShcbiAgICAgICAgICBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgJ25vZGVfbW9kdWxlcycpLFxuICAgICAgICAgIG1vZHVsZVBhdGhcbiAgICAgICAgKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcmlnaW5hbFJlcXVpcmUuY2FsbCh0aGlzLCBtb2R1bGVQYXRoKVxufVxuXG5yZXF1aXJlKCdAYmFiZWwvcmVnaXN0ZXInKSh7XG4gIGJhYmVscmM6IGZhbHNlLFxuICBwcmVzZXRzOiBbXG4gICAgW1xuICAgICAgcGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgJy4uLy4uL2JhYmVsLXByZXNldC5qcycpLFxuICAgICAge1xuICAgICAgICBub2RlOiB0cnVlLFxuICAgICAgfSxcbiAgICBdLFxuICBdLFxuICBpZ25vcmU6IFtcbiAgICBmdW5jdGlvbiBiYWJlbElnbm9yZShmaWxlbmFtZSkge1xuICAgICAgLy8gdHJ1ZSBpZiBzaG91bGQgaWdub3JlXG4gICAgICByZXR1cm4gKFxuICAgICAgICBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cChgJHtwYXRoLnNlcH1ub2RlX21vZHVsZXMke3BhdGguc2VwfWApKS50ZXN0KFxuICAgICAgICAgIGZpbGVuYW1lXG4gICAgICAgICkgfHxcbiAgICAgICAgKGlnbm9yZVBhdGggJiYgaWdub3JlUGF0aC50ZXN0KGZpbGVuYW1lKSlcbiAgICAgIClcbiAgICB9LFxuICBdLFxufSlcblxuLy8gbmVjZXNzYXJ5IGF0IGFueSBlbnRyeSBwb2ludCBvZiB0aGUgY2xpIHRvIGVuc3VyZSB0aGF0IEJhYmVsLXJlZ2lzdGVyXG4vLyBkb2VzIG5vdCBhdHRlbXB0IHRvIHRyYW5zZm9ybSBub24gSmF2YVNjcmlwdCBmaWxlcy5cbmNvbnN0IGlnbm9yZWRFeHRlbnNpb25zID0gW1xuICAnY3NzJyxcbiAgJ3Njc3MnLFxuICAnc3R5bCcsXG4gICdsZXNzJyxcbiAgJ3BuZycsXG4gICdnaWYnLFxuICAnanBnJyxcbiAgJ2pwZWcnLFxuICAnc3ZnJyxcbiAgJ3dvZmYnLFxuICAnd29mZjInLFxuICAndHRmJyxcbiAgJ2VvdCcsXG4gICdvdGYnLFxuICAnbXA0JyxcbiAgJ3dlYm0nLFxuICAnb2dnJyxcbiAgJ21wMycsXG4gICd3YXYnLFxuICAnbWQnLFxuICAneWFtbCcsXG5dXG5pZ25vcmVkRXh0ZW5zaW9ucy5mb3JFYWNoKGV4dCA9PiB7XG4gIHJlcXVpcmUuZXh0ZW5zaW9uc1tgLiR7ZXh0fWBdID0gKCkgPT4ge31cbn0pXG5cbmNvbnN0IG9yaWdpbmFsQ29uc29sZUVycm9yID0gY29uc29sZS5lcnJvclxuY29uc29sZS5lcnJvciA9ICguLi5hcmdzKSA9PiB7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICBjb25zdCBbZXJyLCAuLi5yZXN0XSA9IGFyZ3NcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgY29uc29sZS5sb2cobmV3IFByZXR0eUVycm9yKCkucmVuZGVyKGVyciksIC4uLnJlc3QpXG4gICAgcmV0dXJuXG4gIH1cblxuICByZXR1cm4gb3JpZ2luYWxDb25zb2xlRXJyb3IoZXJyLCAuLi5yZXN0KVxufVxuXG4vLyBCZSBzdXJlIHRvIGxvZyB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgdW5oYW5kbGVkIGV4Y2VwdGlvbnMuIFRoaXMgc2hvdWxkIHNlcmlvdXNseVxuLy8gYmUgYSBkZWZhdWx0OiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzk1MjMjaXNzdWVjb21tZW50LTI1OTMwMzA3OVxucHJvY2Vzcy5vbigndW5oYW5kbGVkUmVqZWN0aW9uJywgciA9PiB7XG4gIGNvbnNvbGUuZXJyb3Iocilcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXRJZ25vcmVQYXRoKHBhdGgpIHtcbiAgICBpZ25vcmVQYXRoID0gcGF0aCA/IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKHBhdGgpKSA6IHVuZGVmaW5lZFxuICB9LFxufVxuIl19
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.absoluteToRelativeChunkName = exports.chunkNameFromFile = void 0;

var _path = _interopRequireDefault(require("path"));

var _ = require(".");

// Instead of using path.sep, we always want to test for all of them. This makes
// the tests consistent and means we can write tests with either separator
var escapedPathSeps = (0, _.escapeRegExp)("".concat(_path["default"].win32.sep).concat(_path["default"].posix.sep));

var chunkNameFromFile = function chunkNameFromFile(filename) {
  // Normalize filename for path.join
  filename = filename.replace(new RegExp("[".concat(escapedPathSeps, "]"), 'g'), _path["default"].sep); // Remove the extension

  return _path["default"].join(_path["default"].dirname(filename), _path["default"].basename(filename, _path["default"].extname(filename))) // Remove the drive letter or leading (back)slash
  .replace(/^(?:[A-Z]:)?(?:\\|\/)/, '') // Now turn it into a name
  .replace(new RegExp("[".concat(escapedPathSeps, "]"), 'g'), '-');
};

exports.chunkNameFromFile = chunkNameFromFile;

var absoluteToRelativeChunkName = function absoluteToRelativeChunkName(ROOT, chunkName) {
  var pathPrefix = chunkNameFromFile(ROOT);
  chunkName = chunkNameFromFile(chunkName); // inner components can simply be added aswell

  if (!chunkName.startsWith(pathPrefix)) {
    return chunkName;
  } // The templates starts with the absolute path, that's the one we want to
  // replace. It's length + 1 because otherwise it would start with a hyphen


  return chunkName.substring(pathPrefix.length + 1);
};

exports.absoluteToRelativeChunkName = absoluteToRelativeChunkName;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9jaHVua0J1aWxkZXIuanMiXSwibmFtZXMiOlsiZXNjYXBlZFBhdGhTZXBzIiwicGF0aCIsIndpbjMyIiwic2VwIiwicG9zaXgiLCJjaHVua05hbWVGcm9tRmlsZSIsImZpbGVuYW1lIiwicmVwbGFjZSIsIlJlZ0V4cCIsImpvaW4iLCJkaXJuYW1lIiwiYmFzZW5hbWUiLCJleHRuYW1lIiwiYWJzb2x1dGVUb1JlbGF0aXZlQ2h1bmtOYW1lIiwiUk9PVCIsImNodW5rTmFtZSIsInBhdGhQcmVmaXgiLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwibGVuZ3RoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBTUEsZUFBZSxHQUFHLDhCQUFnQkMsaUJBQUtDLEtBQUwsQ0FBV0MsR0FBM0IsU0FBaUNGLGlCQUFLRyxLQUFMLENBQVdELEdBQTVDLEVBQXhCOztBQUVPLElBQU1FLGlCQUFpQixHQUFHLFNBQXBCQSxpQkFBb0IsQ0FBQUMsUUFBUSxFQUFJO0FBQzNDO0FBQ0FBLEVBQUFBLFFBQVEsR0FBR0EsUUFBUSxDQUFDQyxPQUFULENBQWlCLElBQUlDLE1BQUosWUFBZVIsZUFBZixRQUFtQyxHQUFuQyxDQUFqQixFQUEwREMsaUJBQUtFLEdBQS9ELENBQVgsQ0FGMkMsQ0FHM0M7O0FBQ0EsU0FDRUYsaUJBQ0dRLElBREgsQ0FFSVIsaUJBQUtTLE9BQUwsQ0FBYUosUUFBYixDQUZKLEVBR0lMLGlCQUFLVSxRQUFMLENBQWNMLFFBQWQsRUFBd0JMLGlCQUFLVyxPQUFMLENBQWFOLFFBQWIsQ0FBeEIsQ0FISixFQUtFO0FBTEYsR0FNR0MsT0FOSCxDQU1XLHVCQU5YLEVBTW9DLEVBTnBDLEVBT0U7QUFQRixHQVFHQSxPQVJILENBUVcsSUFBSUMsTUFBSixZQUFlUixlQUFmLFFBQW1DLEdBQW5DLENBUlgsRUFRb0QsR0FScEQsQ0FERjtBQVdELENBZk07Ozs7QUFpQkEsSUFBTWEsMkJBQTJCLEdBQUcsU0FBOUJBLDJCQUE4QixDQUFDQyxJQUFELEVBQU9DLFNBQVAsRUFBcUI7QUFDOUQsTUFBTUMsVUFBVSxHQUFHWCxpQkFBaUIsQ0FBQ1MsSUFBRCxDQUFwQztBQUNBQyxFQUFBQSxTQUFTLEdBQUdWLGlCQUFpQixDQUFDVSxTQUFELENBQTdCLENBRjhELENBSTlEOztBQUNBLE1BQUksQ0FBQ0EsU0FBUyxDQUFDRSxVQUFWLENBQXFCRCxVQUFyQixDQUFMLEVBQXVDO0FBQ3JDLFdBQU9ELFNBQVA7QUFDRCxHQVA2RCxDQVM5RDtBQUNBOzs7QUFDQSxTQUFPQSxTQUFTLENBQUNHLFNBQVYsQ0FBb0JGLFVBQVUsQ0FBQ0csTUFBWCxHQUFvQixDQUF4QyxDQUFQO0FBQ0QsQ0FaTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gJ3BhdGgnXG5cbmltcG9ydCB7IGVzY2FwZVJlZ0V4cCB9IGZyb20gJy4nXG5cbi8vIEluc3RlYWQgb2YgdXNpbmcgcGF0aC5zZXAsIHdlIGFsd2F5cyB3YW50IHRvIHRlc3QgZm9yIGFsbCBvZiB0aGVtLiBUaGlzIG1ha2VzXG4vLyB0aGUgdGVzdHMgY29uc2lzdGVudCBhbmQgbWVhbnMgd2UgY2FuIHdyaXRlIHRlc3RzIHdpdGggZWl0aGVyIHNlcGFyYXRvclxuY29uc3QgZXNjYXBlZFBhdGhTZXBzID0gZXNjYXBlUmVnRXhwKGAke3BhdGgud2luMzIuc2VwfSR7cGF0aC5wb3NpeC5zZXB9YClcblxuZXhwb3J0IGNvbnN0IGNodW5rTmFtZUZyb21GaWxlID0gZmlsZW5hbWUgPT4ge1xuICAvLyBOb3JtYWxpemUgZmlsZW5hbWUgZm9yIHBhdGguam9pblxuICBmaWxlbmFtZSA9IGZpbGVuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChgWyR7ZXNjYXBlZFBhdGhTZXBzfV1gLCAnZycpLCBwYXRoLnNlcClcbiAgLy8gUmVtb3ZlIHRoZSBleHRlbnNpb25cbiAgcmV0dXJuIChcbiAgICBwYXRoXG4gICAgICAuam9pbihcbiAgICAgICAgcGF0aC5kaXJuYW1lKGZpbGVuYW1lKSxcbiAgICAgICAgcGF0aC5iYXNlbmFtZShmaWxlbmFtZSwgcGF0aC5leHRuYW1lKGZpbGVuYW1lKSlcbiAgICAgIClcbiAgICAgIC8vIFJlbW92ZSB0aGUgZHJpdmUgbGV0dGVyIG9yIGxlYWRpbmcgKGJhY2spc2xhc2hcbiAgICAgIC5yZXBsYWNlKC9eKD86W0EtWl06KT8oPzpcXFxcfFxcLykvLCAnJylcbiAgICAgIC8vIE5vdyB0dXJuIGl0IGludG8gYSBuYW1lXG4gICAgICAucmVwbGFjZShuZXcgUmVnRXhwKGBbJHtlc2NhcGVkUGF0aFNlcHN9XWAsICdnJyksICctJylcbiAgKVxufVxuXG5leHBvcnQgY29uc3QgYWJzb2x1dGVUb1JlbGF0aXZlQ2h1bmtOYW1lID0gKFJPT1QsIGNodW5rTmFtZSkgPT4ge1xuICBjb25zdCBwYXRoUHJlZml4ID0gY2h1bmtOYW1lRnJvbUZpbGUoUk9PVClcbiAgY2h1bmtOYW1lID0gY2h1bmtOYW1lRnJvbUZpbGUoY2h1bmtOYW1lKVxuXG4gIC8vIGlubmVyIGNvbXBvbmVudHMgY2FuIHNpbXBseSBiZSBhZGRlZCBhc3dlbGxcbiAgaWYgKCFjaHVua05hbWUuc3RhcnRzV2l0aChwYXRoUHJlZml4KSkge1xuICAgIHJldHVybiBjaHVua05hbWVcbiAgfVxuXG4gIC8vIFRoZSB0ZW1wbGF0ZXMgc3RhcnRzIHdpdGggdGhlIGFic29sdXRlIHBhdGgsIHRoYXQncyB0aGUgb25lIHdlIHdhbnQgdG9cbiAgLy8gcmVwbGFjZS4gSXQncyBsZW5ndGggKyAxIGJlY2F1c2Ugb3RoZXJ3aXNlIGl0IHdvdWxkIHN0YXJ0IHdpdGggYSBoeXBoZW5cbiAgcmV0dXJuIGNodW5rTmFtZS5zdWJzdHJpbmcocGF0aFByZWZpeC5sZW5ndGggKyAxKVxufVxuIl19